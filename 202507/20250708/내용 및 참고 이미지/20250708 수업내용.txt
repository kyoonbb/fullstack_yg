페이지 경로 구분을 통해서 특정 경로마다 서로 다른 페이지를 제공하는 기능 -> Dynamic Page
경로를 한개의 파일에서 일괄 처리하는 기능 -> 가변 페이지

한개의 파일에서 여러개의 경로를 처리할 수 있게 되었고
해당 경로마다 어떤 데이터를 어떻게 처리할지를 구분만 해두면 금방 제작할 수 있도록 구성

지금까지 배워왔던 NextJS의 기능들은 모두 Frontend의 기능만 배웠다
NextJS는 프론트 프레임워크가 아니다
백엔드의 기능도 포함된 프레임워크다

백엔드의 기능을 오늘 전부 배우는가?
단순히 기능만 배운다면 하루로 되겠지만 조금더 자세히 배우기 위해서 오늘, 내일에 걸쳐서 배운다

프론트엔드의 개념
  눈에 보이는것을 만들어내는 기술
  웹 페이지, 이미지, 영상, 게임의 화면, 앱의 디자인, ...

백엔드의 개념
  눈에 보이지 않는것을 만들어내는 기술
  웹의 정보(게시글), 이미지의 링크, 게임의 로직, 앱의 로직, ...

  문제는 웹페이지를 개발할때 눈에 보이는것을 어디까지를 눈에 보인다고하느냐?
  바로 사용자가 확인할 수 있는 부분을 눈에 보인다 -> 프론트엔드라고 한다

  즉, 웹페이지 개발에서 백엔드는 서버의 동작을 일컷는다
  하지만 이렇게만 나누면 CSR은 Client Side 이기 때문에 프론트엔드가 맞는데
  SSR은 Server Side 이기 때문에 백엔드로 구분해야된다

  서버에서 동작하는 "페이지를 만들지 않는 부분" 을 백엔드
  그외 나머지를 프론트


이러한 "페이지를 만들지 않는 부분"을 백엔드로 구현해야 하는데 이걸 어떻게하는가?
  app/home/ -> 경로가 된다
  app/home/page.tsx -> 해당 경로의 SSR이 된다
    훅은 쓰고싶다 -> SSR이 아닌 CSR을 하고싶다
    page.tsx 가장 윗줄(최상단)에 "'use client'"를 적으면 된다

  이렇게 page.tsx에서 <div></div> 같이 태그를 반환하기 때문에 이것이 프론트엔드로 동작
  그렇다면 태그가 아닌 값만 반환하는 경로가 있다면 그것은 백엔드라고 부를 수 있겠다

  app/api -> Application Interface라는 이름에 걸맞게 백엔드 전용 경로를 만드는 폴더 ### 잘 기억해야 함 백엔드 모음집이다
    해당 폴더 하위 경로들은 Server Side 이면서 Layout이 붙지 않기에
    return한 값을 그대로 제공하는 백엔드 기능이 된다
    무조건 백엔드는 보안 규약을 우회가 아닌 무시기에 서버에서 동작해야함
    이러한 백엔드는 "무조건" Server Side여야 하기에 최상단에 "use client"를 붙이면 안된다

    이렇게 만들때 api 폴더는 경로가 되는게 아니라 기능으로써 동작 $$$참고 이미지 1 참조
      app/api/board             -> /board
      app/api/board/[variable]  -> /board/{variable}

      비슷하게 프론트엔드에도 경로 무시 폴더가 존재
        app/(side)/board              -> /board
        app/(side)/board/[variable]   -> /board/{variable}

        이걸 이용해서 아래와 같이 구성 : 이렇게 구성하는 경우가 많다.
          app/(app)/    => 실제 웹페이지(프론트엔드)
          app/api/      => 기능(백엔드)

  이제 api 폴더 하위에 page가 아닌 기능용 경로를 만들었으니 page.tsx를 만들면 되는가?
    아니다. 기능을 만들기 위해서는 page를 만들기위한 이름의 page.tsx가 아니라
    기능을 만들기위한 이름의 파일을 만들어야한다 -> route.tsx

    즉, route.tsx가 백엔드의 기능을 구현하는 파일 $$$참고 이미지 2 참조

  이제 route.tsx에서 기능을 export하면 NextJS가 자동으로 연결
  문제는 백엔드는 요청의 종류가 있다는것 -> Method

  이러한 Method를 보안적, 기능적 이슈 때문에 구분하면서 export를 해야한다
  그래서 route.tsx에서는 함수를 여러개 내보내기할 수 있어야한다
  그러다보니 export default가 아니라 일반 export로 정해진 명칭의 함수를 내보내기해야 한다

  export하는 함수의 이름은 method명칭으로 정해진다
    export function GET(){}  => Method GET 방식의 요청에 대응하는 경로
    export function POST(){} => Method POST 방식의 요청에 대응하는 경로

  주의사항 : 중요한 점 
    GET 방식의 Method를 만들면 해당 경로의 page.tsx가 먹통이 된다
    왜냐하면 page.tsx가 GET 방식이기 때문에 GET 방식을 만들면 충돌
      app/api/home/route.tsx -> GET -> /home
      app/home/page.tsx -> Page -> /home
      이 두개가 동일하게 /home을 GET으로 이용하기 때문에 충돌

    또 한가지 api 폴더는 어디에나 있을수 있는가?
      안된다.
      정확히는 route.tsx은 어디든지 생성이 가능
      꼭 app/api 아래에 만들 필요는 없다
      하지만 app/api 아래에 만드는 이유는 프론트 폴더와 백 폴더를 구분하기위해서
      어디서든지 route.tsx를 만들수 있는것과 별개로 api 폴더는 app/api 있는 경우가 아니면
      *** 그냥 경로로 동작 ### 왜냐하면 우리가 api 폴더명을 쓸 수 도 있으니 그렇다 구분용으로 쓰이지 않는다 그래서 app/api에 백엔드를 모아둔다

  이러한 백엔드에서 결과값(최종) 이걸 그냥 return하는게 아니라 Response라는 객체로 반환해야한다
    Response -> Web의 기본 객체
  이걸 써서 반환해도 되지만 NextJS에 걸맞게 쓰기위해서 해당 객체의 확장판인 NextResponse를 이용한다
    import {NextResponse} from 'next/server';

    app/api/board 첫 예제 참고

    npx next dev --turbo : turbo 개발할 때 옵션인데 갱신을 빠르게 하고 기능이 추가되었다? 백엔드 하면서부터 이게 없으면 이게 느려짐
    이거 쓰기 귀찮으면 이전에 배웠던 package.json 들어가서 스크립트 추가해라 $$$참고 이미지 3,4 참조

    $$$ 나중에 get 방식으로 테스트한 다음에 post로 바꾸는걸 추천한다. post로 하려면 postman 깔아야 함

   $$$ 여기서 부터 중요하다. ### 강사님의 실책이다. 최신버전 바뀌어서 한탄하신다. 그래서 위가 크게 의미 없다.
   
   이렇게 만들때 app/api에서 api가 경로로 안쓰이는건 예전 버전이고 최신 버전은 api가 경로로 쓰인다
    app/(api)/
    app/(app)/
    위처럼 만들어야 원래 사용하던것처럼 사용이 가능하다

    $$$ 오류가 생겻다고 리턴 안하면 서버 터짐, 왜냐하면 계속 기다리다가 서버가 다운된다
    $$$ 즉 사용자가 요청하고 서버가 문제가 생겨도 문제가 생겼다고 리턴해야한다

  이렇게 백엔드는 만드는 방식은
  원하는 경로의 route 에다가 원하는 method의 함수를 만들고
  해당 함수에서 동작을 하고 동작한 결과를 NextResponse로 반환하는것 $$$참고 이미지 5~7 참조


NextResponse
  .json(보낼정보, 옵션) $$$ 가장 많이 쓸 예정
    내가 가지고있는 어떤 데이터를 JSON의 형태로 바꿔서 전달하는 함수
    JSON.stringify() 함수로 바꾼다음에 전달해야하는걸 내부에서 알아서 처리해주는 함수
  .redirect(URL, 옵션)                                                       $$$ route.tsx 3번 예제
    해당 경로에 접근시 특정 동작을 하고 다른 URL로 이동시키는 함수
    특정 경로에 접근한 대상을 여러 URL로 보낼때 사용

    단, form 태그일때만 자동 사용
    fetch로 동작하는 코드에서는 redirect가 자동으로 이동되지 않는다
    보안 이슈 때문에 수동 구현을 해야한다
  .next(옵션)
    백엔드에는 Middleware라는것이 존재 $$$ 매우 어려움 스프링부트에선 딱히 안쓸거임 이런게 있다라는거만 보자
    Request -> Server -> Middleware -> Endpoint -> User
                                    -> Endpoint -> User
                                    -> Endpoint -> User
    Middleware에서 다음 Middleware 또는 Endpoint로 이동하도록하는 함수
    즉, 이 함수를 안쓰면 현재 Middleware에서 결과를 내겠다는 의미
    $$$ 선택을 할 수 있게 만든 것

  {옵션} $$$ 가장 많이 쓰는 json(보낼정보, 옵션)의 옵션임
    status $$$ 백엔드 정보를 반환받을 경로를 만들 수 있게된다.
      number 자료형으로써 현재 응답하는 데이터의 상태를 나타내는 숫자
        200 -> 성공
        404 -> Not Found
        500 -> Server Error
      번호를 매김으로써 메시지(데이터)와 별개로 어떤 상태인지를 명시

이러한 NextResponse를 이용해서 응답을 할 수 있게되면
이제 사용자로부터 받아온 데이터로 정보를 생산하고 사용자에게 응답하면된다

이제 Path Variable 같이 가변 정보로부터 정보를 받아오고 그걸로 정보를 생산하고 싶은데
어떻게해야 경로 정보를 가져올 수 있는가?

이걸 알기 위해서는 Method 응답함수가 어떤걸 받아오는지를 알아야한다
Method 응답함수는 총 2개의 매개변수를 받아오는데
  NextRequest -> 내일 자세하게 배울 요청 정보를 담는 객체
  props -> 우리가 일반적으로 요청하는 정보의 단위 객체, page에서 쓰는것

  $$$ /app/api/boards/variable 폴더 안에 route.tsx에 예제 1번 및 $$$참고 이미지 8 참조

JS는 동기화 언어
  비동기가 구조적으로 불가능
  그래서 JS의 비동기는 동기화 구조를 비동기화 처럼 보이게 만든것

  그래서 JS에서 대규모 비동기 기능을 구현하는건 알맞지 않다
  왜냐하면 일정 이상의 request를 받으면 프리징이 생기기 때문

  즉, JS 언어로된 NextJS로 백엔드를 구현하면 이걸 고려하면서 코드를 구성해야한다

  이런걸 고려하지 않아도 되도록 자동으로 지원하는 언어를 사용하게 된것 -> Java


///////////////////////////////////// 연습 문제 /////////////////////////////////////
0. 아래 기능을 구현하시오

1. /boards 에 접속시 1 ~ 1000번 출력
  - 1. 각 번호는 /board/1 ~ /board/1000 링크 Soft Navigation

2. /boards/page/{number} 접속시 페이지에 해당하는 번호 출력
  - 1. 1 페이지는 1 ~ 10, 2 페이지는 11 ~ 20, ... Pagenation 구현
  - 2. 각 페이지를 넘나들 수 있도록 이전 페이지와 다음 페이지 Soft Navigation
  - 3. 최소 페이지와 최대 페이지에서는 이전 페이지와 다음 페이지 링크 제거
  - 4. 각 번호는 /board/1 ~ /board/1000 링크 Soft Navigation

3. /board/{number} 접속시 해당 번호 출력
  - 1. 해당 번호를 page.tsx가 아닌 route.tsx로 출력
