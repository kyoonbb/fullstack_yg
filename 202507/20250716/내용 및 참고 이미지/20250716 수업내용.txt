저번 시간에는 NextJS의 JWT를 포함해서 양적 서버에서 인증 정보를 교환하는 방법에대해서 배웠다
JWT를 포함해서 서로 다른 서버에서 인증 정보를 교환할 수 있게되었고 그로 인해 서버를 양적 증가시킬 수있게되었다

여러개의 서버를 개발할 수 있게되었는데 문제는 이러한 방식은 NextJS에서는 그다지 많이 쓰이지 않는다
NextJS는 기본적으로 소규모 또는 중규모 프로젝트에 특화된 프레임워크이기 때문
JS 자체가 대규모 프로그램 개발에 걸맞지 않다

JS는 Browser에서 돌아가기 위해서 만들어졌고 그로 인해서 비동기 기능이 엄청나게 특화되어있지 않다
그러다보니 비동기를 극한으로 끌어올리는 문법이 만들기가 쉽지않다

JS는 비동기의 성능보다 안정성과 편리성을 더 우선시한 언어이기 때문
문제는 이런것들이 대규모 프로젝트에서는 발목을 잡는 일이 될 수 있다는것

물론 프론트엔드 서버는 이런일이 생길 일이 거의 없다
왜냐하면 웹페이지를 렌더링하고 제공하는게 끝이니까

백엔드 서버같은 경우는 여러가지 기능을 포함하고 그만큼 리소스를 소비하기 때문에 
만약 대규모 프로젝트의 백엔드를 만든다면 상황에 따라서 비동기가 버벅일때가 생긴다

Javascript
  [User] -> [Server] -> [Response]
  [User] -> [Server] -> [Response] -> [Response]
  [User] ->

Other
  [User] -> [Server] -> [Response]
  [User] -> [Server] -> [Response]
  [User] ->          -> [Response]

어느정도의 기술력이 필요한 웹사이트의 경우 백엔드 개발시 NextJS는 후순위로 밀리게 된다
NextJS 대신 백엔드에서 비동기의 성능을 최대한 끌어올리는 언어를 선택하게 되었고 
그게 바로 오늘부터 배울 Java & Spring Boot 다.

즉, Java와 Spring Boot를 선택한 이유는 단순하게 비동기의 성능을 언어적 한계를 뛰어넘어서 사용하기위해서
JS로는 리소스 소비에 한계가 있기 때문에 그걸 뛰어넘기 위해서 사용한다

Java와 Spring Boot를 쓰기위해서는 IDE를 선택하고 설정해야한다
  Eclipse, Intellij, VSCode, Visual Studio, Vim, SublimeText, Notepad++, ...

오늘 처음 할일은 VSCode에 Java와 Spring Boot를 사용하기위한 세팅
  1. JDK 23 설치
    JDK 21도 혹시나의 상황에서 설치
    자바 버전에 따라서 Spring Boot의 버전도 달라진다
    그에 맞게 문법이나 기능도 달라지게 된다
      JDK 17  -> web.xml 파일을 매우 중요시한다
      JDK 21+ -> @Annotation을 중요시한다
  
  2. 환경 변수 설정 $$$ 알아서 찾아서 하자
    기본 설정으로 Java 설치시 C:\Program Files\Java\jdk-버전 에 설치되어있다
    해당하는 폴더를 JAVA_HOME 환경 변수로 설정

  3. 환경 변수 Path 추가 $$$ 알아서 찾아서 하자
    환경 변수 상단에 Path에 편집 클릭
    경로에 %JAVA_HOME%\bin 추가
      C:\Program Files\Java\jdk-버전\bin 을 추가한것

  4. VSCode의 Extension에서 Java를 사용하기위한 확장 설치 $$$ 참고이미지 1 참조
    Java 사용에 관련된 모든 Extension 설치
      Extension Pack for Java
    Java에서 매우 유용히 사용되는 추가 패키지 Extension
      Lombok Annotations Support for VS Code

  5. Java 사용 테스트
    test.java 파일 생성
      class Application {
        public static void main(String[] args) {
          System.out.println("Hello World!");
        }
      }

이렇게 세팅을하고 자바를 사용하면 그냥 코드를 "직접" 관리해야한다
하지만 Eclipse 등에서 사용하면 .java 파일 맨위에 packages com.frame.abc; 식으로
어느 폴더 안에있는지를 자동 명시

Project를 직접 관리하지 않고 대신 관리하도록하는 명령이 생기면 좋겠다
Java에서는 Project를 직접 관리하지 않고 대신 관리하는 Project 관리 툴이 존재 -> Gradle, Maven
이러한 프로젝트 관리 툴을 이용한다면 추가적인 패키지가 필요하다 했을때 자동으로 관리

추가 패키지 필요
  수동
    직접 웹사이트 접속
    직접 다운로드
    직접 프로젝트에 추가

    이로인해 프로젝트의 용량 증가
    다른 위치로 이동시
      큰 용량의 파일을 전부 이동
      필수 코드만 이동하고 다시 직접 다운로드받거나

  자동
    툴이 자동 다운로드 및 추가
    
    추가된 패키지는 프로젝트가 아닌 외부 경로에 저장되기에
    프로젝트 용량에는 변화 없음
    다른 위치로 이동시
      코드만 이동해도 해당 위치에서 자동으로 다시 다운로드 및 추가

Spring과 Spring Boot를 쓸때 이러한 프로젝트 관리 툴로 사용한다
왜냐하면 사용하지 않는다면 프로젝트 작성의 어려움과 관리의 어려움이 몇배는 늘어나기 때문

Gradle 방식
  Key.SubKey.ThirdKey
  Key:
    SubKey:
      ThirdKey=Value
Maven 방식
  Key.SubKey.ThirdKey
  <Key>
    <SubKey>
      <ThirdKey>Value</ThirdKey>
    </SubKey>
  </Key>

이렇게 Maven 방식이 용량은 많이 차지해도 직관적이기에 Maven 방식으로 배운다
둘 중 무엇을 이용하던 기능상 차이는 없기에 보편적으로 많이 이용하고 편리한걸 쓴다

이제 이러한 Maven 관리 툴을 활용해야하는데 사용 방법이 2가지가 있다
  1. VSCode 상단에 검색란을 클릭하고 사용하는법
    상단 검색창 클릭
    나오는 검색창에 > 입력
    maven 검색
  2. 단축키를 이용한 방법
    Ctrl + Shift + P 클릭
    maven 검색

이러한 Maven 관리툴 명령어로 사용하는 작업
  1. Maven을 이용한 프로젝트 생성 $$$ 참고이미지 ４시리즈 참조
    Spring Boot 에서 쓰는 방법 -> 나중에
    Java Project에서 쓰는 방법
      Java: Create Java Project 선택
      Maven 선택
      Maven Archetype Quickstart 선택
        Archetype
          많이 이용되는 프로젝트의 형태를 미리 세팅해둔것
      버전 선택
      Group ID 입력
        Group ID
          해당하는 프로젝트가 어떤 폴더에 들어있을지 패키지 폴더 구조를 설명
          src/com/java/app.java
          패키지의 그룹을 지정하는 명칭
      Artifact ID 입력
        Artifact ID
          패키지의 그룹 안에서 내가 누구인지를 지칭하는 명칭
          src/com/java/mine/app.java
          해당 그룹 안에서 내가 어떤 폴더인지를 명시하는 명칭
      해당 프로젝트를 생성할 위치 지정
      해당 프로젝트로 이동

  2. Maven을 이용한 프로젝트 실행 $$$ 참고이미지 5시리즈 참조
    Ctrl + Shift + P 클릭 OR f1

    Maven: Execute Commands 검색
    verify 선택

    단순하게 실행하는것이아닌 실행이 가능한지를 검증하기위해 실행

    만약 검증의 용도가 아닌 단순 실행을 해보고 싶은거라면 Run 버튼 클릭

  3. Maven을 이용한 프로젝트 추출 $$$ 이거 클린 & 인스톨 중요 올릴때 클린하고 받고 다시 실행할 때 인스톨
    Ctrl + Shift + P 클릭
    Maven: Execute Commands 검색
    clean 선택
      이전에 했던 install 과정의 부산물을 삭제
    install 선택
      우리가 작업한 내용을 .class 로 번역
      .jar로 압축
      이러한 작업 내용물을 target 폴더에 모아둔다
  
  4. Maven을 이용한 패키지 관리
    Ctrl + Shift + P 클릭
    Maven: Add a dependency 검색
    원하는 패키지의 Group Id or Artifact Id 검색 후 선택
    선택을하게되면 해당 패키지를 관리한다고 명시하게 되고 명시된 파일을 다운로드 및 연동하게된다

pom.xml $$$ 추가적으로 설정 필요한 것
  Maven 설정 파일
  Maven이 어떻게 관리하고 무엇을 관리하는지를 명시하는 명세서

  <packaging></packaging>
    jar, war을 적는 속성
    maven install로 결과물을 추출할때 Java Archive 로 추출할지
    Web Archive로 추출할지 선택하는 속성
    무엇을 선택하느냐에 따라 추출하는 파일의 확장자와 내부 구조가 달라지는 속성

    하지만 우리는 왠만하면 끝까지 JAR만 사용한다
    Spring Boot의 Spring Web은 Tomcat이란 서버를 내장하고 있기 때문에 WAR을 쓸 필요가 없다

  <properties></properties>
    현재 프로젝트의 설정을 작성하는 속성

    <maven.compiler.source></maven.compiler.source> $$$ 나는 21 버전이다
      Java 실행 버전
    <maven.compiler.target></maven.compiler.target>
      Java Test 버전 

    src/main/
      실제 개발하는 경로
    src/test/ $$$ 보통 초보는 시간 많이 잡아먹어서 잘 안씀
      코드를 테스트하기위한 단위 테스트 경로 
  
  <dependencies></dependencies>
    외부에서 다운로드 받고자하는 의존성 패키지 목록을 명시하는 속성
    의존성 목록을 무엇을 받을지 모르겠다면 사이트에서 확인
      https://mvnrepository.com/
    
    <dependency></dependency>
      다운로드하는 의존성 패키지

$$$ 이정도까지는 기억하고 관리하자


Java에서 클래스의 관련 함수를 "자동"으로 만들어주는 패키지 -> Lombok

Lombok
  컴파일 직전에 코드를 읽고 코드에서 요구하는 함수를 만든 후에 컴파일하는것
  즉, Java를 이용해서 개발할때는 클래스 코드의 양을 획기적으로 줄이는 패키지이기에
  거의 반 필수적인 패키지

  아까 설치한 Lombok Annotations Support for VS Code 는 Lombok이 컴파일 전에 동작하도록 순서 변경 확장
  이클립스도 마찬가지로 단순 패키지 추가만으로는 동작이 안되고 설치가 필요

  Lombok 패키지 설치시 헷갈리지 않게 아래의 패키지를 설치  $$$ 참고이미지 9 참조
    org.projectlombok.lombok

  또한 이러한 Lombok은 컴파일전에 자동 동작하기에 Annotation을 추가하기만하면 된다

Lombok Annotation
  모든 Lombok의 함수는 camelCase로 구성

  @Getter
    해당 클래스의 변수에 해당하는 get 함수를 제작
      A -> getA
      B -> getB
      hello -> getHello

  @Setter
    해당 클래스의 변수에 해당하는 set 함수를 제작
      A -> setA
      B -> setB
      hello -> setHello

  @ToString
    해당 클래스의 toString 메서드 오버라이딩
    해당 클래스의 변수 내용들을 확인할 수 있도록 오버라이딩
    만약 비밀번호같이 불필요한 내용을 제외하고 싶다면 exclude 옵션으로 제외
      @ToString(exclude = { "pw" })

  @EqualsAndHashCode
    해당 클래스의 equals, hashCode 함수를 오버라이딩
    단순 비교가 아닌 깊은 비교를 하도록 오버라이딩하는 기능

  @NoArgsConstructor
    해당 클래스의 매개변수 없는 생성자를 오버라이딩

  @AllArgsConstructor
    해당 클래스의 모든 변수가 매개변수로 있는 생성자를 오버라이딩

  @RequiredArgsConstructor
    해당 클래스의 final 변수가 매개변수로 있는 생성자를 오버라이딩

  @Data
    @Getter, @Setter, @RequiredArgsConstructor, @ToString, @EqualsAndHashCode 를 합친 기능

//////////////////////////////////// 연습 ////////////////////////////////////
1. 연습 문제 풀이
2. Maven 프로젝트로 구구단 생성 프로젝트 생성 후 실행
  - 1. 구구단의 단수를 Dan 클래스로 관리
  - 2. 구구단의 행수를 Hang 클래스로 관리
  - 3. 구구단을 Dan, Hang을 가지는 Gugudan 클래스로 관리
  - 4. 구구단의 정보를 첫줄에 출력하고 구구단 내용 출력