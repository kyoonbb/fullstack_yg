Hook을 이용해서 컴포넌트를 제어하고 웹페이지를 만들다보면 Dynamic한 웹페이지를 손쉽게 만들게된다
Hook을 이용해서 Dynamic한 웹페이지를 만들다보면 생기는 Issue가 있다

성능 Issue
  리액트의 컴포넌트는 함수단위로 실행된다
  상위 컴포넌트에서 하위 컴포넌트를 함수로써 실행하는 경우가 발생한다
    <Top>
      <Bottom/>
    </Top>
  너무나도 당연히 상위 렌더링시 하위가 렌더링 되다보니 성능이 나빠질 수 밖에 없다
    A -> B -> C -> D -> E
  이런일이 생기는 이유는 하위 컴포넌트도 변경해야할 수 있기 때문에 다시 렌더링하니 그런것
  하지만 하위 컴포넌트가 상위 컴포넌트의 값에 종속되지 않고 별개로 동작한다면
  굳이 다시 렌더링할 필요가 없다

이러한 성능 이슈를 해결하기위해서 React에서는 특정 컴포넌트, 특정 데이터를 캐싱(메모제이션)하는 훅이 나오게 되었다

메모제이션
  변수 및 함수 등을 미리 저장해두고 변경사항이 없다면 새로 만들지 않고 원래 있던 대상을 이용하는 방법
  즉, 메모제이션을 이용한다면 렌더링을 다시할 필요 없는 대상을 처음 상태 그대로 이용하도록 고정할 수 도 있다

  메모제이션은 아무때나 쓰지 않고 성능을 많이 소비하는 대상에게만 쓴다
  왜냐하면 메모제이션을 하면 RAM(메모리)를 많이 소비 하기 때문
  그래서 메모제이션을 다른 말로 최적화 라고 부른다

메모제이션 훅
  useMemo
    값을 미리 캐싱해두는 훅

    사용법
      const 변수 = useMemo(()=>{ return 값; }, [의존성배열]);

    A - B
      - C
    
    이렇게 태그 구조가 있을때
    A를 바꾸면 B,C가 함께 바뀌는데
    useMemo를 이용하면 A가 바뀌어도 B,C를 다시 렌더링되지 않도록 할 수 있고
    필요할때만 렌더링되도록 만들수가 있다

    주의할점
      메모제이션을 CSR(Client Side Rendering)에서만 동작한다
      정확히는 "모든 Hook"은 CSR만 된다
      Hook은 상태를 관리하는건데 서버에서 관리하면 트래픽 문제도 있고 하다보니
      Client에서 자체 관리를 한다

  useCallback
    함수를 미리 캐싱해두는 훅
    리액트 컴포넌트를 사용하다보면 익명 함수(Lambda 함수)를 매우 많이 만들게 된다
    문제는 이러한 람다함수를 만들게되면 람다 함수는 그때그때 생성을 하기 때문에 성능 저하를 일으킨다는것

    람다함수는 좋은 기능을 가지고 있지만 반복 수행을할때는 성능적으로 좋지는 못하다

    그래서 람다로 만든 함수를 이용하면 람다가 아무련 변화가 없더라도 성능을 조금씩 더 많이 사용하게 된다
    그래서 이러한 문제를 회피하기위해 함수에 변화가 없다면 이전 함수를 그대로 사용하는 방법

    그래서 함수의 결과값이 아니라 함수 자체를 기록해두고 변화가 없다면 계속 이용하는 훅

    사용법
      const func = useCallback(()=>{}, [의존성 배열]);
      첫번째로 넣은 함수가 다음번에도 변경되지 않고 고정된다


이제 이러한 메모제이션을 하면 메모리를 소비하는 대신 속도를 빠르게 처리할 수 있게된다
하지만 사용하다보면 가끔 메모리를 소비하고싶지도 않고 속도를 빠르게 하고싶다
이러한 방법은 react를 안쓰고 JS Only로 작업하면 된다

메모제이션의 메모리를 소비하는 단점을 우회하기위해서 "직접 태그를 제어하는" 방법이 존재한다
훅중에는 메모제이션과 목적은 동일한데 단지 대상이 "실존하는 태그"인 훅이 있다
  useRef
    실제 태그에 접근 가능한 변수를 만드는 훅

    사용법
      const ref = useRef();
      <tag ref={ref}/>

      이후에 ref.current라고 적으면 지정된 태그를 사용할 수 있게 만드느것

////////////////////////////////////// 연습 문제 //////////////////////////////////////
TodoList 제작
  Todo 정보
    title, content, visible
    [ title ]
    [content] 형식으로 보여야함
    visible이 true면 그대로 보이고 false면 중간에 취소선이 그어져야한다
  Todo정보를 클릭하면 visible을 true,false로 반전할 수 있도록

https://zoom.us/rec/share/wtSTh3bRpffX7VgY7ccv8-eoSQlNWLGbbggaIoxpmOOm61KApOpdjHxNoLZATIxq.IVxK3biI9Y6bFvQY 
암호: *?0gakMS